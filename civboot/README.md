One "big scary" thing in software is encryption. It is often said you shouldn't
roll your own... but we really have to if Civboot is to be a real thing.

Can we use an ultra-simple encryption? Is such a thing possible? Symetric
encryption is significantly easier to implement than asymetric. It relys on
reversible mathematical operations, many of which can be implemented
performantly on extremely minimal hardware.

## Bigkey encryption

Bigkey is a symetric encryption/decryption protocol made for Civboot which uses
miniaml resources but requires a large 1KiB key. The encryption protocol is
designed to work on hardware limited devices for the Civboot.org project.

Bigkey does not use a password, instead the user is expected to keep a physical
copy of their randomly-generated key on a media such as USB/etc (if it is being
used for physical access to a device).

Other uses are below. For any two-client system the key must first be
transmitted over secure (i.e. physical) means:
- Encryption of a file or file-system.
- Identity verification between parties with the key.
- Encryption/decryption between parties with the key.

BigKey uses a 1024 byte (1KiB) key which should contain 256 randomly generated
U32 values.

The key should never be shared with anybody, although a user should make several
copies and store them in safe places to avoid loss of data in the event they
loose their key. If the key is lost, a new one should be created and updated,
since the data will no longer be secure.

Encryption psuedo-code in python:
```
# add random 16 bytes so the "end" cannot be guessed.
unencrpyted = padRandom16Bytes() + unencrpyted

# create buffers for storing result
encrypted = [0] * len(unencrypted)
indexes = [0] * len(unencrpyted)

# encrypt data
for i in reversed(range(len(unencrypted))):
  value = unencrypted[i]
  index = value % 256
  value = bit_rotate_left(value, key[index] % 32)
  value = value + key[index]
  value = value ^ key[index]
  indexes[i] = index
  encrypted[i] = value

# shuffle the indexes using the key
for i in range(len(indexes)):
  k = key[i] % 256
  indexes[i], indexes[k] = indexes[k], indexes[i]
```

Both the encrypted data, it's length and the indexes are then stored or
transmitted over the wire. This has the obvious disadvantage that it
bloats the size of the data by at least 25%.

Decryption in python:
```
# unshuffle indexes
for i in reversed(range(len(indexes))):
  k = key[i] % 256
  indexes[i], indexes[k] = indexes[k], indexes[i]

# decryption can then happen as a stream
decrypted = [0] * len(encrypted)
for i in range(len(indexes)):
  index = indexes[i]
  value = encrypted[i]
  value = value ^ key[index]
  value = value - key[index]
  value = bit_rotate_right(value, key[index] % 32)
  decrypted[i] = value

decrypted = removeRandomBytes(decrypted) # discard randomly generated bytes
```

# Some notes

- [nice analogy](https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/)
- [maths.org public key cryptography](https://nrich.maths.org/2200)
